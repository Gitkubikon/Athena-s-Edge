from flask_jwt_extended import JWTManager, create_access_token, jwt_required
from flask import Flask, request, jsonify, send_from_directory, session
from flask_cors import CORS
import datetime
import json
import os
import shutil
import threading

metadata_lock = threading.Lock()
session_lock = threading.Lock()

app = Flask(__name__)

CORS(app)
app.config['SECRET_KEY'] = 'sabalimbalim'  # Set a secret key for JWT
jwt = JWTManager(app)  # Initialize JWT
app.config["JWT_ACCESS_TOKEN_EXPIRES"] = 3600

CONTENT_FOLDER = "content"
METADATA_FILE = "metadata.json"

class InvalidUsage(Exception):
    def __init__(self, message, status_code=400, payload=None):
        super().__init__()
        self.message = message
        self.status_code = status_code
        self.payload = payload

    def to_dict(self):
        rv = dict(self.payload or ())
        rv['message'] = self.message
        return rv

@app.errorhandler(InvalidUsage)
def handle_invalid_usage(error):
    response = jsonify(error.to_dict())
    response.status_code = error.status_code
    return response

@app.errorhandler(404)
def handle_not_found(error):
    return jsonify({"message": f"404 Not Found: {request.url}"}, error), 404

@app.errorhandler(401)
def handle_unauthorized(error):
    return jsonify({"message": f"Unauthorized: {request.url}"}, error), 401

@app.errorhandler(Exception)
def handle_generic_error(error):
    return jsonify({"message": "An error occurred", "error": str(error)}), 500


class SaveMetadataError(Exception):
    def __init__(self, message):
        super().__init__()
        self.message = message

@app.errorhandler(SaveMetadataError)
def handle_save_metadata_error(error):
    response = jsonify({"message": error.message})
    response.status_code = 500
    return response


class MetadataError(Exception):
    def __init__(self, message):
        super().__init__()
        self.message = message

@app.errorhandler(MetadataError)
def handle_metadata_error(error):
    response = jsonify({"message": error.message})
    response.status_code = 500
    return response


def save_metadata(metadata):
    metadata_path = os.path.join(CONTENT_FOLDER, METADATA_FILE)

    # Check if the file exists
    if not os.path.exists(metadata_path):
        # Create the file with a default structure
        default_metadata = {}
        with open(metadata_path, "w") as f:
            json.dump(default_metadata, f)

    # Write the metadata
    try:
        with open(metadata_path, "w") as f:
            json.dump(metadata, f)
    except Exception as e:
        raise SaveMetadataError(f"Error saving metadata file: {e}")

def load_metadata():
    try:
        with open(os.path.join(CONTENT_FOLDER, METADATA_FILE), "r") as f:
            metadata = json.load(f)
    except FileNotFoundError:
        # Create an empty metadata.json file
        with open(os.path.join(CONTENT_FOLDER, METADATA_FILE), "w") as f:
            json.dump({}, f)
        metadata = {}
    except json.JSONDecodeError as e:
        raise MetadataError(f"Error loading metadata file: {e}")
    return metadata


# Generate JWT token
@app.route('/login', methods=['POST'])
def login():
    with open('config.json', 'r') as f:
        config = json.load(f)
    if request.json is None:
        raise InvalidUsage("Missing request body", status_code=400)
    password = request.json.get('password', '')
    username = request.json.get('username', '')
    if not username:
        raise InvalidUsage("Username is required", status_code=400)
    if not password:
        raise InvalidUsage("Password is required", status_code=400)
    if username not in config['users'] or password != config['users'][username]:
        raise InvalidUsage("Invalid credentials", status_code=401)
    token = create_access_token(identity=username)
    return jsonify({"token": token}), 200



@app.route('/metadata', methods=['GET'])
def get_metadata():
    try:
        with open(os.path.join(CONTENT_FOLDER, METADATA_FILE), "r") as f:
            metadata = json.load(f)
            return jsonify(metadata), 200
    except FileNotFoundError:
        raise InvalidUsage("Metadata file not found", status_code=404)
    except json.JSONDecodeError as e:
        raise InvalidUsage(f"Error loading metadata file: {e}", status_code=400)



@app.route('/articles/<category>/<article>', methods=['GET'])
def get_article(category, article):
    try:
        article_folder = os.path.join(CONTENT_FOLDER, category, article)
        with open(os.path.join(article_folder, "index.md"), "r") as f:
            article_text = f.read()
    except FileNotFoundError:
        raise InvalidUsage(f"Article {article} not found in category {category}", status_code=404)

    with metadata_lock:
        metadata = load_metadata()
        try:
            metadata_article = metadata[category][article]
        except KeyError:
            return jsonify({"message": f"Metadata not found for article {article} in category {category}"}), 404

    with session_lock:
        # Check if the current session has already viewed the article
        if 'viewed_articles' not in session:
            session['viewed_articles'] = []

        if article not in session['viewed_articles']:
            # Increment the view count for the article
            with metadata_lock:
                metadata_article["engagement"]["views"] += 1

            # Add the article to the viewed_articles list for the current session
            session['viewed_articles'].append(article)

            # Save the updated metadata and session data
            with metadata_lock:
                save_metadata(metadata)
            session.modified = True

    return jsonify({
        "article_text": article_text, 
        "metadata": metadata_article, 
        "views": metadata_article["engagement"]["views"]
    }), 200


@app.route('/articles/<category>/<article>', methods=['PATCH'])
def patch_article(category, article):
    article_folder = os.path.join(CONTENT_FOLDER, category, article)
    if not os.path.exists(article_folder):
        raise InvalidUsage("Article not found", status_code=404)

    metadata = load_metadata()
    if article not in metadata:
        raise InvalidUsage("Metadata not found for article '{}' in category '{}'".format(article, category), status_code=400)

    content = request.get_json().get('content')
    if content:
        with open(os.path.join(CONTENT_FOLDER, category, article, "index.md"), "w") as f:
            f.write(content)

    for key, value in request.get_json().items():
        metadata[category][article][key] = value

    metadata[category][article]["modified_at"] = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    save_metadata(metadata)

    return jsonify({"metadata": metadata[category][article]}), 200


@app.route('/articles/<category>/<article>', methods=['PUT'])
@jwt_required()
def put_article(category, article):
    article_folder = os.path.join(CONTENT_FOLDER, category, article)

    try:
        os.makedirs(article_folder, exist_ok=True)
    except OSError as e:
        raise InvalidUsage("Failed to create article folder", payload={"error": str(e)})

    try:

        os.makedirs(article_folder, exist_ok=True)

        with open(os.path.join(article_folder, "index.md"), "w") as f:
            f.write("# New Article\n")   # write the main heading
            f.write("## Content\n")   # write the subheading
            f.write("Here is some content for the article.")   # write the content

        content_type = request.content_type
        if content_type == 'application/json':
            payload = request.get_json()
        else:
            payload = None

        metadata = load_metadata()

        template = {
          "article": "",
          "images": [],
          "videos": [],
          "tags": [],
        "popularity": 0,
         "sentiment": {
         "sentiment_categories": {
             "positive": "",
              "negative": "",
             "neutral": ""
            },
            "sentiment_keywords": ""
        },
        "engagement": {
            "likes": 0,
            "comments": 0,
            "shares": 0
            }
        }
    
        metadata[category][article] = template.copy()
        metadata[category][article].update(payload)
        metadata[category][article]["created_at"] = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        try:
            save_metadata(metadata)
        except Exception as e:
            raise InvalidUsage("Failed to save Metadata", payload={"error": str(e)})
        
        return jsonify({
            "message": "Article updated successfully",
            "article": {
                "category": category,
                "name": article,
                "metadata": metadata[category][article]
            }
        })
    
    except Exception as e:
        raise InvalidUsage("Failed to create article", payload={"error": str(e)})


@app.route("/media/<category>/<article>/<media_type>/<filename>", methods=["PUT"])
@jwt_required()
def put_media(category, article, media_type, filename):
    try:
        if media_type not in ["images", "videos"]:
            raise InvalidUsage(f"{media_type} not allowed", status_code=400)

        if media_type == "cover":
            media_dir = os.path.join(CONTENT_FOLDER, category, article)
        else:
            media_dir = os.path.join(CONTENT_FOLDER, category, article, media_type)

        if not os.path.exists(media_dir):
            os.makedirs(media_dir)

        file_path = os.path.join(media_dir, filename)

        if os.path.exists(file_path):
            os.remove(file_path)

        with open(file_path, "wb") as f:
            f.write(request.data)

        # Update metadata for the uploaded image
        metadata = load_metadata()
        metadata[category][article][media_type].append(file_path)
        metadata[category][article]["modified_at"] = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        save_metadata(metadata)

        return jsonify({"message": f"{filename} uploaded successfully"}), 200

    except Exception as e:
        return handle_generic_error(e)



@app.route("/media/<category>/<article>/<media_type>/<filename>", methods=["GET"])
@jwt_required()
def get_media(category, article, media_type, filename):
    if media_type not in ["images", "videos", "cover"]:
        raise InvalidUsage(f"{media_type} not allowed", status_code=400)

    if media_type == "cover":
        media_dir = os.path.join(CONTENT_FOLDER, category, article)
    else:
        media_dir = os.path.join(CONTENT_FOLDER, category, article, media_type)

    try:
        return send_from_directory(media_dir, filename)
    except FileNotFoundError:
        raise InvalidUsage(f"File not found: {filename}", status_code=404)




@app.route('/media/<category>/<article>/<media_type>/<media>', methods=['DELETE'])
@jwt_required()
def delete_media(category, article, media_type, media):
    # Check if article and media exist
    if not os.path.exists(os.path.join(CONTENT_FOLDER, category, article, media)):
        return handle_not_found(Exception(f"{media_type} {media} not found for article {article} in category {category}"))

    try:
        if media_type == "cover":
            media_path = os.path.join(CONTENT_FOLDER, category, article, f"{media}")
        else:
            media_path = os.path.join(CONTENT_FOLDER, category, article, media_type, f"{media}")
        os.remove(media_path)

        # Update metadata for the deleted media
        metadata = load_metadata()
        if media_type not in metadata[category][article]:
            metadata[category][article][media_type] = {}
        metadata[category][article][media_type].remove(media_path)
        metadata[category][article]["modified_at"] = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        save_metadata(metadata)

    except Exception as e:
        return handle_generic_error(e)

    return '', 204


@app.route('/articles/<category>/<article>', methods=['DELETE'])
@jwt_required()
def delete_article(category, article):
    article_folder = os.path.join(CONTENT_FOLDER, category, article)
    if not os.path.exists(article_folder):
        raise InvalidUsage("Article not found", status_code=404)

    metadata = load_metadata()
    if article not in metadata:
        raise InvalidUsage("Article metadata not found", status_code=404)
        
    # delete the article
    shutil.rmtree(article_folder)
    del metadata[category][article]
    save_metadata(metadata)

    return jsonify({"message": "Article deleted successfully"}), 200


if __name__ == '__main__':
    dev_mode = False
    if dev_mode:
        app.run(debug=True, port=3000)
    else:
        app.run(host='0.0.0.0', port=80)
